<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乙酰胆碱</title>
  
  <subtitle>四肢不勤 | 五谷不分 | 一事无成</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-02T14:57:59.749Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>所谓死亡</title>
    <link href="http://yoursite.com/2019/07/03/%E6%89%80%E8%B0%93%E6%AD%BB%E4%BA%A1/"/>
    <id>http://yoursite.com/2019/07/03/所谓死亡/</id>
    <published>2019-07-03T05:00:43.000Z</published>
    <updated>2019-07-02T14:57:59.749Z</updated>
    
    <content type="html"><![CDATA[<p>死亡恐惧就是全人类的梦魇，它有如一把达摩克利斯之剑，永远悬挂在人的头顶，不知道何时会落下。<br><a id="more"></a></p><p>许多宗教恰恰就是以这种全人类共通的极致的恐惧为基础，建立起宗教神学高楼大厦的。</p><p>宗教告诉你，只要听从我们的教义，通过神明的指引，便可以永远活下去，达到永恒。</p><p>有的宗教说，有罪之人非要下炼狱，虔诚之人可上达天国。到了炼狱是比死还难受，受尽折磨；上了天国那才真是永恒和幸福。既然你怕死，怕死后的那种虚无感，那我就告诉你，人死后其实还有灵魂，灵魂还有去处，只要你足够虔诚，听从神的引导，那么进入天国之后可比人间还要幸福。如果你不信仰我，那可得要受炼狱的折磨不可。</p><p>有的宗教说，生命就是轮回，通过一次次的轮回实现延续。而在每次轮回中，可能你的生命形态都不一样，并且对之前的轮回都无觉知。善人可以在善道轮回，恶人却在恶道轮回，善道比起恶道要少受些折磨，但仍然还是逃不出轮回。不过只要你信仰我们的教义，使用我们的修炼方法，是可以到达彼岸，超脱轮回的，那时候便不再有痛苦，更不会有生死，是真正的永恒。</p><p>有的宗教说，只要你潜心修炼，感悟天地自然，历尽三灾五劫，就能够达到长生。</p><p>不仅如此，只要你信仰我们，我们还能帮你驱魔辟邪，降妖除魔，保证你寿元完全耗尽而不会中途暴毙。</p><p>真好，一条龙服务。</p><p>不管怎么说，虔诚的信仰确实也常常能帮人消减痛苦和恐惧。</p><p>我就是一个很怕死的人，死亡的焦虑和恐惧常常会使我恐慌。</p><p>不过我最近发现，手抄一遍《心经》，能够缓解我的一些焦虑。（当然目前来看我还算是唯物主义者，不信任何宗教）</p><p>其实并不是说《心经》真的有这么神奇，只是这一种方法应该适用很多人，焦虑的时候，尝试静下来，抄抄写写自己喜欢的句子，书摘之类的。</p><p>存在主义说，我们是必死的生物，我们有自我意识，知道自己终有一死。但如果你对这个事实进行彻底的逃避和否认，无疑会加重你对这个事实的肯定。</p><p>很多死亡教育会把重点放在生上面，而不是死。未知生，焉知死。它常常会告诉你，人怕死不是真的怕死，而是怕无意义的生，有意义地生，能够让人不畏惧死。</p><p>然后告诉你，把每天当成最后一天来过。excuse me？那我可能会更焦虑更恐惧，每天都在想着今天就是最后一天，明天可能就要凉了。</p><p>可别吧……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;死亡恐惧就是全人类的梦魇，它有如一把达摩克利斯之剑，永远悬挂在人的头顶，不知道何时会落下。&lt;br&gt;
    
    </summary>
    
    
      <category term="胡思乱想" scheme="http://yoursite.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>PTB从入门到放弃05 --- 刺激呈现</title>
    <link href="http://yoursite.com/2019/07/03/PTB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8305%20---%20%E5%88%BA%E6%BF%80%E5%91%88%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/03/PTB从入门到放弃05 --- 刺激呈现/</id>
    <published>2019-07-03T04:53:14.000Z</published>
    <updated>2019-07-03T07:02:16.742Z</updated>
    
    <content type="html"><![CDATA[<p>还没开始写。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还没开始写。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PTB从入门到放弃04 --- 数据存储</title>
    <link href="http://yoursite.com/2019/07/02/PTB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8304%20---%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/07/02/PTB从入门到放弃04 --- 数据存储/</id>
    <published>2019-07-02T04:13:01.000Z</published>
    <updated>2019-07-02T06:46:13.207Z</updated>
    
    <content type="html"><![CDATA[<p>关于诸如反应时之类的数据存储，估计绝大多数计算机专业的人都会使用结构数组来保存数据，这种方法我自己以前尝试过，不过我觉得有点复杂，也可能是我没有深厚的计算机语言基础，使用起来略觉别扭。后面我自己摸索出来矩阵作为matlab最大的特点，用矩阵来保存数据简直简单粗暴。<br><a id="more"></a></p><p>所以这里我只介绍矩阵的使用方式，结构数组我并不涉及。</p><h4 id="1-数组和矩阵的概念"><a href="#1-数组和矩阵的概念" class="headerlink" title="1 数组和矩阵的概念"></a>1 数组和矩阵的概念</h4><p>数组是计算机概念，在各种语言里都有它的存在。矩阵是数学概念，但是matlab的最大特色就是矩阵运算，所以大家在使用matlab时，会经常把数组和矩阵当作是一回事。</p><p>我比较喜欢用矩阵的叫法，所以下面统一称为矩阵。</p><p>矩阵有分维度，比如1维矩阵，也可以叫做向量，是1行*n列的形式。</p><pre><code>a = [1,2,3,4,5]a = 1     2     3     4     5</code></pre><p>比如a就是1个向量，它只有1行，有5个数，或者说5列。</p><p>二维矩阵就是n行*n列。</p><pre><code>b = [1,2,3,4,5;5,4,3,2,1]b = 1     2     3     4     5 5     4     3     2     1</code></pre><p>b就是2行*5列的矩阵。</p><p>三维矩阵就是n行*n列*n页。</p><p>先新建两个矩阵，a1和a2。</p><pre><code>a1 = 1     2     3     4     5 5     4     3     2     1a2 = 6     7     8     9    1010     9     8     7     6</code></pre><p>然后，</p><pre><code>c(:,:,1) = a1c(:,:,2) = a2c(:,:,1) = 1     2     3     4     5 5     4     3     2     1c(:,:,2) = 6     7     8     9    1010     9     8     7     6</code></pre><p>这样c就变成了一个三维矩阵。就像两页纸一样，第一页纸上面写着：</p><pre><code>c(:,:,1) = 1     2     3     4     5 5     4     3     2     1</code></pre><p>这一个二维矩阵，而第二页纸上面写着另一个二维矩阵：</p><pre><code>c(:,:,2) = 6     7     8     9    1010     9     8     7     6</code></pre><p>所以三维矩阵的第三个元素叫做页。</p><p>如果你觉得有点难，没关系，到此为止了，不会再说第四维第五维了。事实上，绝大部分问题都只需要用到二维矩阵就能解决，三维矩阵基本上不会使用到，至少在认知行为实验程序里面根本用不到。知道是怎么回事就行。</p><h4 id="2-二维矩阵建立"><a href="#2-二维矩阵建立" class="headerlink" title="2 二维矩阵建立"></a>2 二维矩阵建立</h4><p>第一种方法，纯手动生成。</p><p>直接把一个写好的矩阵赋值给变量：</p><pre><code>a = [1,2;2,1]a = 1     2 2     1</code></pre><p>第二种办法，for循环生成，</p><pre><code>for i = 1:5    for j = 1:5        b(i,j)=j;    endend</code></pre><p>生成5*5的矩阵：</p><pre><code>b = 1     2     3     4     5 1     2     3     4     5 1     2     3     4     5 1     2     3     4     5 1     2     3     4     5</code></pre><p>但是这样页麻烦，有没有更简单的办法？有！matlab本来就是矩阵运算工具，有无数种方法让你轻而易举建立矩阵。</p><p>第三种办法就是特殊函数直接生成。比如<code>rand(n)</code>，就是生成0~1范围内随机数字的n*n矩阵。比如,</p><pre><code>rand(5)ans = 0.8147    0.0975    0.1576    0.1419    0.6557 0.9058    0.2785    0.9706    0.4218    0.0357 0.1270    0.5469    0.9572    0.9157    0.8491 0.9134    0.9575    0.4854    0.7922    0.9340 0.6324    0.9649    0.8003    0.9595    0.6787</code></pre><p>或者<code>ones(n)</code>，生成n*n的值为1的矩阵，</p><pre><code>ones(4)ans = 1     1     1     1 1     1     1     1 1     1     1     1 1     1     1     1</code></pre><p>同理，<code>zeros(n)</code>，就是生成n*n的值为0的矩阵。</p><p>我最经常使用的也是建立0矩阵来保存数据。</p><h4 id="3-数据存放"><a href="#3-数据存放" class="headerlink" title="3 数据存放"></a>3 数据存放</h4><p>假如现在我的一个实验正式阶段有5个block，每个block有100个trial，总共就有500个trial。再有，我的实验因变量只需要被试的反应时，那么最简单的，我建立一个500*2的矩阵来存放数据就够了，第一行用来存放trial序号，第二行用来存放反应时。</p><p><img src="https://hbimg.huabanimg.com/3f9bd61cac18b67496c4db493f47ca43873e623b165d7-ecfI2W_fw658" alt="datasavep1"></p><pre><code>for trial = 1:500    data = zeros(500,2); %生成500行*2列的0矩阵    data(trial,1) = trial; %把trial变量的值赋值给第trial行第1列    data(trial,2) = secs - t_start; %secs是03里面的按键时间，t_start是刺激呈现的时间，二者相减就是反应时。end</code></pre><p>这样就得到一个存放反应时的500*2的矩阵变量data了。data变量可以保存成matlab的变量文件.mat的格式，也可以保存输出成excel表格。</p><p>一般来说，保存就mat格式的原文件就行了，因为做统计分析我们也是可以在matlab里完成的，当然SPSS分析可能会更专业点，所以你也完全可以保存一个mat文件，再保存一个excel文件。当然mat文件里的数据也是可以单独复制到excel里的。</p><p>不过我们的实验需要的不仅仅是反应时。如果只是简单的两列数据，会丢失掉很多的信息，你不知道这些反应时分别对应的是哪个自变量水平，以及其他一些你需要分析的信息。</p><p>所以你完全可以建立一个列数更多的矩阵，行数还是保持不变。比如现在需要自变量水平，那就再加一列，zeros(500,3)，第一列还是放trial序号，第二列放自变量水平，第三列放反应时。</p><p>需要再加其他信息数值同理。</p><h4 id="4-数据文件保存输出"><a href="#4-数据文件保存输出" class="headerlink" title="4 数据文件保存输出"></a>4 数据文件保存输出</h4><p>保存为excel格式，</p><pre><code>xlswrite(&apos;filename&apos;,data); %data是保存数据的二维矩阵</code></pre><p>保存为mat格式，</p><pre><code>save(&apos;filename&apos;,&apos;data&apos;); </code></pre><p>保存excel格式需要给文件名加上后缀.xls，mat格式需要给后缀加上.mat。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于诸如反应时之类的数据存储，估计绝大多数计算机专业的人都会使用结构数组来保存数据，这种方法我自己以前尝试过，不过我觉得有点复杂，也可能是我没有深厚的计算机语言基础，使用起来略觉别扭。后面我自己摸索出来矩阵作为matlab最大的特点，用矩阵来保存数据简直简单粗暴。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PTB从入门到放弃03 --- 按键反应收集</title>
    <link href="http://yoursite.com/2019/07/01/PTB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8303%20---%20%E6%8C%89%E9%94%AE%E5%8F%8D%E5%BA%94%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/07/01/PTB从入门到放弃03 --- 按键反应收集/</id>
    <published>2019-07-01T03:00:00.000Z</published>
    <updated>2019-07-02T03:56:15.903Z</updated>
    
    <content type="html"><![CDATA[<p>在02里面只提到了按键等待，但是认知行为实验是需要收集被试的按键反应的正确与错误的信息以及反应正确时被试的反应时的。我们需要先收集被试的按键，然后再让程序自己拿这个被试的按键去与已经写好的正确与否判断语句进行匹配，然后反应正确，记录下这个反应时，存到数据变量里。<br><a id="more"></a></p><p>在进行按键反应收集之前，我们需要做的，就是设置好相应的键码。</p><h4 id="1-设置键码"><a href="#1-设置键码" class="headerlink" title="1 设置键码"></a>1 设置键码</h4><pre><code>KbNameResult = KbName(arg);</code></pre><p>该函数是用来设置键盘码的。返回值<strong>KbNameResult</strong>返回键的扫描码。扫描码采取的貌似是ASCII码。比如<code>KbName(&#39;space&#39;)</code>空格键对应的是32，也就是返回值是32。</p><p>参数<strong>arg</strong>是指定键名，比如回车是return，空格是space，a就是a这样的。</p><p>因为电脑系统和设备有可能不同，比如windows和mac os，键盘码就有可能不同，所以在每个程序最开始，建议都统一键盘码。</p><pre><code>KbName(&apos;UnifyKeyNames&apos;); %统一键盘码</code></pre><p>假如实验需要用到的按键是a和l，那么我们就设置：</p><pre><code>kba = KbName(&apos;a&apos;);kbl = KbName(&apos;l&apos;);</code></pre><p>变量kba和kbl就是得到的a和l键返回的扫描码。</p><h4 id="2-限制按键"><a href="#2-限制按键" class="headerlink" title="2 限制按键"></a>2 限制按键</h4><p>键盘上的按键很多，有时候怕被试不小心按错，而我们的程序刚好也没有对那些按键采取相应的措施，造成数据异常是一回事。如果不小心按到一些关键按键，导致实验程序崩溃那就更惨了。</p><p>为了避免这种错误的发生，我们可以对按键范围进行限制。</p><p><code>RestrictKeysForKbCheck()</code>函数就是用来对按键范围进行限制的。</p><p>比如我们只要被试对a和l键进行反应，其他按键完全不需要：</p><pre><code>RestrictKeysForKbCheck([KbName(&apos;a&apos;) KbName(&apos;l&apos;)]);</code></pre><p>那么在这之后，除了a和l键之外，程序不会对其他键产生任何反应。</p><p>如果有其他特殊按键，比如设置按Esc键退出程序，也可以加上该按键，这个限制范围完全由你决定。</p><h4 id="3-按键判断"><a href="#3-按键判断" class="headerlink" title="3 按键判断"></a>3 按键判断</h4><pre><code>[keyIsDown, secs, keyCode, deltaSecs] = KbCheck([deviceNumber]);</code></pre><p>4个返回值。</p><p><strong>keyIsDown</strong>，如果有任意的按键行为产生，返回1。</p><p><strong>secs</strong>，跟<code>KbWait()</code>的一样，返回按键产生的时间。</p><p><strong>keyCode</strong>，返回按键的扫描码。和KbName的返回值一样，比如空格space，返回32。</p><p><strong>deltaSecs</strong>，跟<code>KbWait()</code>的一样，返回按键产生时间的置信区间。一般用不到。</p><p>1个参数。</p><p><strong>deviceNumber</strong>，指定查询的键盘设备，如果只有一个键盘，默认即可，不需要设置。</p><pre><code>while true    [~,secs,keyCode]= KbCheck;    if any(keyCode) %对于任意的按键        if keyCode(kba) %如果按的是a键            if 判断呈现的刺激是否与反应匹配，如果是                语句块（反应正确，一般记录下反应时）                反应时=secs-刺激呈现时的时间            else                语句块（反应错误时你要做的事）            end            break; %跳出while循环        elseif keyCode(kbl) %如果按的是l键            if 判断呈现的刺激是否与反应匹配，如果是                语句块（反应正确，一般记录下反应时）                反应时=secs-刺激呈现时的时间            else                语句块（反应错误时你要做的事）            end            break; %跳出while循环        end    endend</code></pre><p>这就是一个简单的按键判断过程原理。先判断按键是什么，再判断这个按键行为是否与刺激匹配，如果匹配，就是正确反应时，那么记录下这个反应时，以及其他你所需要的信息，保存好。然后跳出这个循环，进行下一试次。</p><h4 id="4-反应时获取"><a href="#4-反应时获取" class="headerlink" title="4 反应时获取"></a>4 反应时获取</h4><pre><code>GetSecs</code></pre><p>这个函数是用来获取当前时间值的。它获取的时间精度据说特别高。一般是毫秒级别，如果电脑系统配置了更高精度的时钟，它能达到微秒级。</p><p>在刺激呈现时，使用</p><pre><code>t_start = GetSecs;</code></pre><p>获取刺激呈现的时间点，然后KbCheck返回的按键时间点secs-t_start就等于被试的反应时间。</p><pre><code>restime = secs-t_start;</code></pre><p>该句可以加进去上面KbCheck判断里按键与刺激匹配的语句块里，把时间赋值给变量restime。当然我们一般不这么存储数据，在后面我会讲到存储数据的方式。这里只先简单介绍怎么得到反应时。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在02里面只提到了按键等待，但是认知行为实验是需要收集被试的按键反应的正确与错误的信息以及反应正确时被试的反应时的。我们需要先收集被试的按键，然后再让程序自己拿这个被试的按键去与已经写好的正确与否判断语句进行匹配，然后反应正确，记录下这个反应时，存到数据变量里。&lt;br&gt;
    
    </summary>
    
    
      <category term="psychtoolbox" scheme="http://yoursite.com/tags/psychtoolbox/"/>
    
  </entry>
  
  <entry>
    <title>PTB从入门到放弃02 --- 指导语呈现和键盘鼠标按键等待</title>
    <link href="http://yoursite.com/2019/06/29/PTB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8302%20---%20%E6%8C%87%E5%AF%BC%E8%AF%AD%E5%91%88%E7%8E%B0%E5%92%8C%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87%E6%8C%89%E9%94%AE%E7%AD%89%E5%BE%85/"/>
    <id>http://yoursite.com/2019/06/29/PTB从入门到放弃02 --- 指导语呈现和键盘鼠标按键等待/</id>
    <published>2019-06-29T03:00:00.000Z</published>
    <updated>2019-07-02T03:56:07.745Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍指导语呈现的途径以及简单的键盘和鼠标等待<br><a id="more"></a></p><h3 id="1-指导语呈现"><a href="#1-指导语呈现" class="headerlink" title="1 指导语呈现"></a>1 指导语呈现</h3><p>实现指导语的呈现一般有2种方式：一种是<strong>文字型</strong>，一种是<strong>图片型</strong>。</p><p>第一种文字型，缺点很多，主要是比较复杂，需要写比较多的代码，耗时耗力；而且matlab的中文支持貌似也很差，需要经过各种字符转换和编码转换。优点也有，就是能够匹配任一台电脑。当然这个优点其实可有可无。所以我一般不会用这种方式呈现指导语。</p><p>第二种图片型，会比较简单。思路就是先把指导语打印在一张图片上，然后在PTB里面使用DrawTexture或者PutImage的方式呈现出来。需要的代码跟文字型比起来，简直少得不能再少。所以关于指导语呈现就学这样的方式就够了，省时省力。</p><p>如果你会Photoshop这种类似的图片编辑技能的话，那把文字打印在一张空白图片上对你来说应该轻而易举。如果不会PS，那PPT总会吧？新建空白ppt把指导语打上去，然后另存为图片就可以了，关于图片尺寸也是可以自己在ppt上调整的。如果你跟我说不会把ppt另存为图片，截图总会吧？直接截取ppt上的指导语然后保存成图片。</p><p>有了指导语图片后，我们先使用<strong><code>imread（）</code>函数</strong>读取这张图片为二进制矩阵。</p><pre><code>Image = imread（filename）；</code></pre><p>filename就是图片文件名。如果你喜欢简单粗暴点的，下一步就可以直接把图片打印到屏幕上了。</p><pre><code>Screen(&apos;PutImage&apos;,WindowPtr,Image);</code></pre><p>‘PutImage’函数功能就是放置一张图片。</p><p>两行代码轻轻松松呈现指导语。但是这也有缺点。首先你的图片尺寸是固定的，比如我的电脑屏幕是宽2736x高1824，我在Photoshop上直接把图片尺寸也设置成这个大小，那么就契合屏幕尺寸了。但是如果我的程序拿到另外一台电脑运行，它的屏幕分辨率没有我的电脑这么大，或者比我的还大，那么指导语就会更小或者更大了，不合适。不过如果只是大一点小一点，其实也没有多大影响。</p><p>另一个函数，是可以解决这个问题的，那就是对图片进行缩放，或者其他调整。</p><pre><code>InstrImg = Screen(&apos;MakeTexture&apos;,WindowPtr,Image);Screen(&apos;DrawTexture&apos;,Wptr,InstrImg);</code></pre><p>比上面也就多了一行。</p><p>使用’MakeTexture’先创建纹理缓冲，也就是图片的缓冲，然后再用’DrawTexture’把这个图片缓冲打印出来。呈现效果和’PutImage’其实是一样的，但是’DrawTexture’还多了很多参数可以对图片进行调整。</p><pre><code>Screen(&apos;DrawTexture&apos;, windowPointer, texturePointer [,sourceRect] [,destinationRect] [,rotationAngle] [, filterMode] [, globalAlpha] [, modulateColor] [, textureShader] [, specialFlags] [, auxParameters]);</code></pre><p><strong>texturePointer</strong>，就是’MakeTexture’创建纹理缓冲的指针。</p><p><strong>sourceRect</strong>，指定纹理中的某个区域，默认是整张图片，保持默认即可。</p><p><strong>destinationRect</strong>，指定屏幕中的某个区域来绘制纹理，默认在屏幕中心。</p><p><strong>rotationAngle</strong>，指定纹理旋转角度，默认0度，即不旋转。</p><p>后面的参数基本用不到（反正我没用过，所以也不太会使用那些参数）。</p><p>总而言之’MakeTexture’和’DrawTexture’比’PutImage’的发挥空间要大的多，简单来说就是你可以对图片进行更多的调整。不过其实对于指导语来说，一般’PutImage’就够用了，不用去搞一些花里胡哨的东西。’MakeTexture’和’DrawTexture’一般是用来绘制一些特殊纹理的，比如随机噪音。</p><pre><code>imgarray = 255*rand(200,200); %生成200*200的随机数字imgnoise = Screen(&apos;MakeTexture&apos;,Wptr,imgarray);Screen(&apos;DrawTexture&apos;,Wptr,imgnoise);</code></pre><p>输出的结果就是：</p><p><img src="https://hbimg.huabanimg.com/cc76cf2a447ae677e4d9db9dc47d3657dec6daf5116d0-u26QKd_fw658" alt="noise"></p><p>有时候我们也经常需要用到光栅。</p><p>那么首先了解一下<code>meshgrid(x,y)</code>函数，它是用来生成二维网格矩阵的。如：</p><pre><code>[a,b] = meshgrid(1:4,1:5)；</code></pre><p>结果输出：</p><pre><code>a = 1     2     3     4 1     2     3     4 1     2     3     4 1     2     3     4 1     2     3     4b = 1     1     1     1 2     2     2     2 3     3     3     3 4     4     4     4 5     5     5     5</code></pre><p>a矩阵每一行都是[1,2,3,4]，b矩阵每一列都是[1,2,3,4,5]，a和b都是5行4列。</p><pre><code>[x,y] = meshgrid(1:100,1:100); %生成1：100的两个网格矩阵</code></pre><p>生成的x和y都是100行100列，而x的每一行都是1：100，y的每一列都是1：100.就像一张网格一样。</p><p>然后我们用正弦函数转换一下并输出图片。</p><pre><code>imshow(sin(x))</code></pre><p><code>imshow（）</code>函数是显示图片。结果是：</p><p><img src="https://hbimg.huabanimg.com/1a79b34fef47a8d8d27d0eb3860c3cbdefbe79213bcd-15t7FP_fw658" alt="grating1"></p><p>或者：</p><pre><code>imshow(sin(x+y))</code></pre><p>结果是：</p><p><img src="https://hbimg.huabanimg.com/455004e118b8af9d1332a8147b79880b0203bdc875a9-lcsdWB_fw658" alt="grating2"></p><p>正弦光栅不止于此，任意地去调配x和y的值，你可以玩出花来。</p><h3 id="2-按键等待"><a href="#2-按键等待" class="headerlink" title="2 按键等待"></a>2 按键等待</h3><pre><code>[secs, keyCode, deltaSecs] = KbWait([deviceNumber][, forWhat=0]);</code></pre><p>该函数是用来等待被试的按键行为。在被试产生任意按键（或者可以指定按键）后，马上进入下一条代码运行，如果被试未产生按键，就一直停留在上一个代码语句中（类似于暂停或者休息）。</p><p>三个返回值。</p><p><strong>secs</strong>，返回按键行为发生的时间；</p><p><strong>keyCode</strong>，返回按键的扫描码（即让你知道被试按哪个键），需要结合KbName函数使用；</p><p><strong>deltaSecs</strong>，返回反应时的置信区间。secs是时间点，而deltaSecs是一个区间，告诉你被试的按键行为可能在这个时间段内。因为KbCheck会一遍一遍地检索键盘是否有按键发生，所以可能会产生细小的误差，当然这些误差几乎可以忽略不计。我们只需要使用secs所得到的时间就够了。</p><p>两个可选参数，</p><p><strong>deviceNumber</strong>，指定键盘设备，有时候外接键盘可能不止一个，就需要使用到这个参数。默认是1个，所以不用管它；</p><p><strong>forWhat</strong>，指定获取的是“按下”的还是“释放”的动作，默认值0，表示“按下”动作，值1为“释放”动作，值2是“释放”后再接收被试按下的动作。一般保持默认即可，或者有特殊需求也只到1。</p><p>所需要的参数和返回值视情况而定。一般不需要任何值，</p><pre><code>KbWait；</code></pre><p>还有另外两个相似函数，KbPressWaitb,被试按压等待，相当于KbWait的forwhat参数=0的情况；KbReleaseWait，释放等待，相当于KbWait的forwhat参数=1的情况。一般只需要使用KbWait即可。</p><h3 id="3-等待鼠标点击"><a href="#3-等待鼠标点击" class="headerlink" title="3 等待鼠标点击"></a>3 等待鼠标点击</h3><p>一般的认知行为实验我们都是使用的键盘按键反应，但不排除某些实验有特殊要求，需要用到鼠标反应。</p><pre><code>[clicks,x,y,whichButton] = GetClicks([windowPtrOrScreenNumber][, interclickSecs]);</code></pre><p>四个返回值，</p><p><strong>clicks</strong>，返回值单击=1，双击=2；</p><p><strong>x和y</strong>，返回鼠标操作时的坐标值；</p><p><strong>whichButton</strong>，返回值表示左键=1，中键=2，右键=3。</p><p>两个可选参数，</p><p><strong>windowPtrOrScreenNumber</strong>，屏幕的指针或者编号，即Openwindow所得到的指针和编号。</p><p><strong>interclickSecs</strong>，指定鼠标双击的时间间隔。如果鼠标两此单击的时间间隔小于该值时，视为双击，否则视为单击行为。如果该值设置为0，那么就是忽略双击，只使用单击；如果使用默认值，则使用系统默认的双击判定时间。</p><pre><code>[Clicks] = GetClocks(windowPtr);</code></pre><p>一般只需要写这样就可以了。</p><p>然后常用的代码块可以是这样：</p><pre><code>while true    [clicks] = GetClicks(windowPtr)    if clicks == 1        执行代码块        break; %跳出循环    elseif clicks == 2        执行另一个代码块        break;    endend</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍指导语呈现的途径以及简单的键盘和鼠标等待&lt;br&gt;
    
    </summary>
    
    
      <category term="psychtoolbox" scheme="http://yoursite.com/tags/psychtoolbox/"/>
    
  </entry>
  
  <entry>
    <title>PTB从入门到放弃01 --- psychtoolbox5个基础函数</title>
    <link href="http://yoursite.com/2019/06/28/PTB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8301%20---%20psychtoolbox5%E4%B8%AA%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/06/28/PTB从入门到放弃01 --- psychtoolbox5个基础函数/</id>
    <published>2019-06-28T07:00:00.000Z</published>
    <updated>2019-07-02T03:55:57.520Z</updated>
    
    <content type="html"><![CDATA[<p>matlab刺激的呈现主要是依托于PTB的窗口类函数来实现的。类似于ppt，你在空白的ppt页面上绘制纹理，摆放图形，描述文字，PTB为你提供无限多的空白窗口，你可以在这些窗口上做你想做的任何事。<br><a id="more"></a></p><p>当然到目前为止是静态的，要让它像ppt一样动起来，你还需要使用其他操作类函数来实现，让窗口一个个切换、悬停、与人进行互动、获取外界的反应比如按键和声音、获取反应时，以及把你想要得到的数据，记录下来。</p><p>PTB跟E-Prime不同的是，后者的实验程序编写是可视化的，它给你提供各种对象，比如视频、图像、声音、文字等，你直接拖拽它们到空白的模板上，摆好位置。这个过程你是看得到的。但是PTB是半可视化的，你需要先写脚本代码，使用这些代码在空白的窗口上来绘制刺激。如果你不运行这些脚本代码，你是无法看到这些窗口和刺激的。而这很容易会让你的代码产生bug。</p><p>这里先介绍5个最基础的函数让你体验PTB。</p><p>废话不多说。</p><h1 id="1-创建主页面"><a href="#1-创建主页面" class="headerlink" title="1 创建主页面"></a>1 创建主页面</h1><p>或者我常叫它开屏，就是开启屏幕；如果你的实验有特殊要求，也可以开启多个屏幕。</p><pre><code>[windowPtr,rect] = Screen(&apos;OpenWindow&apos;,windowPtrOrScreenNumber[,color] [,rect] [,pixelSize] [,numberOfBuffers] [,stereomode] [,multisample] [,imagingmode] [,specialFlags] [,clientRect]);</code></pre><p>我们先介绍一下这些参数：</p><blockquote><p>注意一下，在[   ]里的参数是可选参数不是必须参数，即不是一定要去设置的，可以不用设置保持默认值即可</p></blockquote><p><strong>①windowPtr</strong>，函数的第一个返回值。当你使用这个函数开启屏幕的时候，这个函数会返回此屏幕的句柄，或者叫指针。这个返回值是必需的，因为我们的所有刺激呈现都是基于Screen函数的，所以这个句柄的作用就是一个连接所有的Screen函数。比如说我开启了一个屏幕，并且返回了这个参数，假设它的值是1，也就是说，这个值就是这个屏幕的符号或者说编号，它告诉后面所有的Screen函数，你们都要在这个编号为1的屏幕上工作。</p><p><strong>②rect</strong>，函数的第二个返回值。它返回的是一个数组，就是你开启的屏幕的大小，单位是像素。比如我在我的电脑上开启了屏幕，默认全屏开启，那么这个rect返回的就是我的电脑屏幕的尺寸大小，2736x1824，当然它的形式是数组的形式，就是[0，0，2736，1824]这样的。这个返回值并不是必需的。如果你的程序只是想在你的电脑上运行，那么这个参数基本上是不需要的。如果你的程序是想在多个电脑上运行，而且这些电脑的屏幕尺寸大小不一样，那就有必要获取这个参数，后面刺激的呈现要在此基础上进行调整。</p><p>为什么这么说？因为每个电脑的屏幕大小不一样，而PTB的绘制类函数都是需要使用坐标来进行绘制。比方说，我的电脑是宽2736x高1824，现在我在中间的位置[1368，912]绘制一个圆，暂且不管这个圆的大小。我们现在把这个程序拿到另一台电脑上运行，假如这个电脑屏幕尺寸是1920x1080，对它来说，它的中间位置是[960，540]，而圆的坐标还是[1368，912]，那么它会出现在哪？肯定不是正中间，而且还会偏离中间很远。</p><p>如果我们绘制刺激，不使用具体的坐标值，而使用所获得的屏幕尺寸返回值的比例，就可以很容易解决这样的问题。比如我们在绘制圆的时候，使用的坐标是[rect（3）x0.5，rect（4）x0.5]，也就是在宽和高各取一半的这个坐标位置进行绘制，那么不管你在哪台电脑上运行，不管你屏幕大小，这个圆的位置会始终在中间出现（原理是这个原理，但绘制圆的时候不会这么简单，因为绘制圆会涉及到多个参数）。当然最简单的是可以直接使用‘centre’这样的坐标来直接在中央绘制。</p><p><strong>③windowPtrOrScreenNumber</strong>，这个参数是屏幕的序号，一般默认为0，意思是直接覆盖显示器的屏幕，如果是1，就是指向第1个显示器屏幕，如果是2就是指向第2个显示器屏幕。此参数为必须填写参数。默认0即可。</p><p><strong>④color</strong>，指定屏幕的颜色，默认白色，可以是0~255的任一个值，0表示黑色，255表示白色；也可以是[R,G,B]形式的值，比如[255，0，0]表示红色，[0，255，0]表示绿色。根据实验要求进行相应设置即可。</p><p><strong>⑤rect</strong>，指定创建的屏幕大小。这个参数跟前面的rect返回值是一样的，只不过前面的是返回值，而这里的是输入值，是需要你来设置的。一般无需设置，保持默认就行，默认是全屏开启。如果有特殊要求，也可以进行设置。比如我只要一个宽高都是1000像素的正方形屏幕，那么可以设置数值[0，0，1000，1000]，这个数组也可以说是屏幕的坐标。它的形式是[x1，y1，x2，y2]，表示屏幕从x1和y1这个坐标点开始绘制，对角点是x2和y2，也就是固定两个对角点绘制开启屏幕，屏幕的宽高就是x2-x1和y2-y1。[0，0，1000，1000]的意思就是从左上角画1000像素宽高的正方形。[0，0]表示左上角的点，在PTB里，屏幕的坐标原点[0，0]就是左上角，</p><p><strong>⑤pixelSize</strong>，指定屏幕像素深度，用位数来表示存储一个像素需要的位数，默认值是电脑屏幕的设置，可取值8，16，32，等，值越大，表示某个像素的颜色值越丰富。这个参数不需要去设置，基本用不到。除非你的实验对屏幕的颜色需要进行校正之类的。</p><p><strong>⑥numberOfBuffers</strong>，指定缓冲区数。一般不需要设置，默认就行。这个涉及到PTB主页面和缓冲页面的原理。用不到。PTB的主要分为主页面和缓冲页面，一个屏幕绘制好后呈现出来，就是主页面，而下一个屏幕也是绘制好了，存放在缓冲页面里，等待屏幕切换，主页面消失，缓冲页面就马上呈现出来，成为主页面。这样就不需要调用的时候再绘制，可以增加反应时间的精确性等。</p><p><strong>⑥stereomode</strong>，指定是否开启立体模式，默认不开启，据说是要使用到某些立体设备之类的，基本用不到这个，我也没使用过，不懂，跳过。</p><p><strong>⑦multisample</strong>，指定反锯齿优化，基本用不到，跳过。</p><p><strong>⑧imagingmode</strong>，指定图像处理模式，用来控制PTB调用OpenGL这类插件来实现复杂的图像处理，我没用到过，不是很懂，基本上也用不到，跳过。</p><p><strong>⑨specialFlags</strong>，基本用不到，我也不知道怎么用。</p><p><strong>⑩clientRect</strong>，指定绘制区域大小，对绘制内容进行缩放处理，也基本用不到。</p><p>能用得到基本就是前几个参数。我们的第一条代码：</p><pre><code>[windowPtr,rect] = Screen(&apos;OpenWindow&apos;,0); %表示开启屏幕，只设置第一个参数，后面全都默认就行</code></pre><p>如果对屏幕颜色有要求，就：</p><pre><code>[windowPtr,rect] = Screen(&apos;OpenWindow&apos;,0,[250,0,0]); %开启红色屏幕</code></pre><p>如果对屏幕大小有要求，就：</p><pre><code>[windowPtr,rect] = Screen(&apos;OpenWindow&apos;,0,[250,0,0],[0,0,1200,1200]); %开启1200像素的正方形红色窗口</code></pre><h1 id="2-切换页面"><a href="#2-切换页面" class="headerlink" title="2 切换页面"></a>2 切换页面</h1><pre><code>[VBLTimestamp, StimulusOnsetTime, FlipTimestamp,Missed, Beampos] = Screen(&apos;Flip&apos;, windowPtr [, when] [, dontclear] [, dontsync] [, multiflip]);</code></pre><p><strong>①VBLTimestamp</strong>，返回值，记录页面切换开始时刻的时间。</p><p><strong>②StimulusOnsetTime</strong>，返回值，记录刺激呈现时刻的时间。</p><p><strong>③FlipTimestamp</strong>，返回值，记录页面切换结束时刻的时间，FlipTimestamp-VBLTimestamp=一次页面切换的时间。</p><p><strong>④Missed</strong>，返回值，是否发生帧丢失，&gt;0表示丢失，&lt;0表示未丢失。</p><p><strong>⑤Beampos</strong>，返回值，不是很懂这是干嘛的，没用过。</p><p><strong>⑥windowPtr</strong>，屏幕句柄参数，不懂的回上面OpenWindow去看。</p><p><strong>⑦when</strong>，指定页面切换时间，默认值是0，即马上切换，如果设置值&gt;0，表示在这个设置时间后，再进行页面切换。</p><p><strong>⑧dontclear</strong>，指定是否清除帧缓冲，默认值0，表示页面切换后马上清除，1表示不清除，但是会向缓冲区继续绘制新的内容。意思是比如你呈现了一个矩形，下一个页面你要呈现一个圆形，在页面切换的时候如果你不清除这个页面的缓冲，就不会在空白页面上绘制圆形，而是在本来就有一个矩形的页面上继续绘制一个圆形，后面呈现出来的就是一个带有圆形和矩形的界面。</p><p><strong>⑨multiflip</strong>，指定是否切换所有主页面，默认值是0，只切换一个显示器的主页面，如果&gt;0，就是切换所有显示器的页面。一般用不到。</p><p>一般使用的代码是：</p><pre><code>Screen(&apos;Flip&apos;,windowPtr); %马上切换页面</code></pre><p>其他参数不需要管，如果你需要切换的时间这类的返回值，在前面自己加上即可。</p><h1 id="3-关闭屏幕"><a href="#3-关闭屏幕" class="headerlink" title="3 关闭屏幕"></a>3 关闭屏幕</h1><pre><code>Screen(&apos;Close&apos;, windowPtr);</code></pre><p>或者，关闭所有屏幕：</p><pre><code>Screen(&apos;CloseAll&apos;);sca；</code></pre><h1 id="4-等待时间"><a href="#4-等待时间" class="headerlink" title="4 等待时间"></a>4 等待时间</h1><pre><code>[realWakeupTimeSecs] = WaitSecs(waitPeriodSecs); [realWakeupTimeSecs] = WaitSecs(&apos;UntilTime&apos;, whenSecs);[realWakeupTimeSecs] = WaitSecs(&apos;YieldSecs&apos;, waitPeriodSecs);</code></pre><p><strong>①realWakeupTimeSecs</strong>，返回值，返回等待结束时的系统时间。</p><p><strong>②waitPeriodSecs</strong>，指定等待时间，单位是秒，如1就是1秒，0.5就是500毫秒。理想情况下可以精确到1毫秒。</p><p><strong>③whenSecs</strong>，指定直到什么时间结束等待。</p><p>一般使用第一个形式，返回值是否需要视情况而定，一般不需要，代码可以直接写：</p><pre><code>WaitSecs(1); %等待1秒。</code></pre><h1 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h1><pre><code>[newX, newY]=Screen(&apos;DrawText&apos;, windowPtr, text [,x] [,y] [,color] [,backgroundColor] [,yPositionIsBaseline] [,swapTextDirection]);</code></pre><p><strong>①newX, newY</strong>，两个返回值，是一个坐标，返回得到文本绘制后，画笔所在的坐标位置。基本不需要</p><p><strong>②windowPtr</strong>，屏幕句柄，不多说。</p><p><strong>③text</strong>，文本内容，需要用英文输入法下的单引号包括。如果内容是中文，需要使用double（）函数转换。</p><p><strong>④x，y</strong>，指定文本绘制的起始坐标，默认从原点[0，0]开始。</p><p><strong>⑤color</strong>，指定文本颜色，默认黑色，可以是0~255，也可以是[R,G,B]。</p><p><strong>⑥backgroundColor</strong>，指定文本的背景颜色，默认透明（即没有背景色）。一般不需要，如果需要，可以结合textBackgroundColor函数使用。</p><p><strong>⑦yPositionIsBaseline</strong>，指定是否把坐标y当作文本基线，默认0，不需要。</p><p><strong>⑧swapTextDirection</strong>，指定文本输出方向，默认0，即从左到右，如果1则从右到左。（如需要水平和垂直输出可以使用另一个函数DrawFormattedText）。</p><p>一般使用代码为：</p><pre><code>Screen(&apos;DrawText&apos;,windowPtr,&apos;text&apos;,rect(3)/2,rect(4)/2); %在以屏幕中点为起始点输出文本内容</code></pre><blockquote><p>了解这5个函数之后，我们就可以开始初步体验PTB了：</p></blockquote><pre><code>[windowPtr,rect] = Screen(&apos;OpenWindow&apos;,0); %开启屏幕Screen(&apos;DrawText&apos;,windowPtr,&apos;Hello World&apos;,rect(3)/2,rect(4)/2); %在中央坐标绘制&apos;Hello World&apos;文本Screen(&apos;Flip&apos;,windowPtr); %页面切换WaitSecs(2); %等待2秒Screen(&apos;CloseAll&apos;); %关闭所有屏幕</code></pre><p>复制这5行代码到matlab的m文件，运行一下试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;matlab刺激的呈现主要是依托于PTB的窗口类函数来实现的。类似于ppt，你在空白的ppt页面上绘制纹理，摆放图形，描述文字，PTB为你提供无限多的空白窗口，你可以在这些窗口上做你想做的任何事。&lt;br&gt;
    
    </summary>
    
    
      <category term="psychtoolbox" scheme="http://yoursite.com/tags/psychtoolbox/"/>
    
  </entry>
  
  <entry>
    <title>所谓梦想</title>
    <link href="http://yoursite.com/2018/04/10/%E6%89%80%E8%B0%93%E6%A2%A6%E6%83%B3/"/>
    <id>http://yoursite.com/2018/04/10/所谓梦想/</id>
    <published>2018-04-10T13:01:43.000Z</published>
    <updated>2019-07-02T03:56:22.623Z</updated>
    
    <content type="html"><![CDATA[<p>迷茫的时候，总会想要去干一些异想天开的事。比如最近多看了几本应当被划分进文学著作类型的书，就想着作家真的是好生厉害，要不我去跨考个中文系，悄咪咪地混进文学的大门算了。<br><a id="more"></a></p><p>人总是有梦想的，反正当个作家，是我众多梦想之一。惭愧地是，回过头来看，我竟未为这个梦想付出过半点实际努力！这算是幻想了，我应该是期待着哪天突然灵感喷发，莎士比亚狄更斯夏目漱石上身，写出一部旷世巨著，流传千古，成为中国文坛一颗冉冉升起的超新星，身后光芒万丈。</p><p>意淫一下又不犯法。</p><p>不过话说回来，为了实现这个梦想，我倒也是做过一些事的，只不过都被扼杀在萌芽之中。让我们把时间线拉回到四年前。恰逢高考填志愿，我毅然决然地把汉语言文学放在了历史学之后。造化弄人，分数不够以至第一批志愿落榜，这才有了之后我在师大心理学院读了四年心理学的故事。如果真的存在平行世界，也许会有一个我被某个学校汉语言专业录取，一步步走上作家这条道路的世界吧。</p><p>汉语言专业的朋友告诉我，大多数汉语言专业毕业的学生都成为了一名教语文的光荣的人民教师，作家什么的，就别想了吧，那是少数人才能去触碰的东西。</p><p>不友好，又十分辛酸。心理学也是如此，大多数的本科毕业生都从事心理健康教育，成为一名心理老师。至于心理咨询师、心理治疗师，那真的是极少数人才有资格去摘得的桂冠。</p><p>我曾经想写一个故事：</p><p>热血且正义的勇士手握宝剑一路披荆斩棘，终于在极恶之地与大魔王相遇。二话不说勇士提剑朝大魔王砍去，大魔王徒手折断勇士的宝剑，然后一掌拍死了勇士。勇士直到闭上眼睛也想不通，为什么正义打不过邪恶。但其实，正义已经战胜了邪恶。大魔王才是真正的主角，故事的正义，他千难万险才在极恶之地等到了所谓“勇士”，一掌将他毙命。</p><p>一反常理的故事，我觉得框架已经很不错，但迟迟没敢动手。我怕一动手，就毁掉了我构建的奇幻世界。想了一个故事，跟写了一个故事，是全然不同的两件事。谁都可以想，但不是谁都能进行创作的。想的时候天花乱坠，等到想要下笔时，却苍白无力。</p><p>我觉得我的脑洞还算大，灵感也不少，但也就只停留在想象的阶段。就像，上帝已经把世界的框架都搭好了，准备开始大创世的时候，发现自己半点神力也没有，什么也造不出来，那真是件极其尴尬的事。</p><p>但即使一点神力都没有，人也能够在想象世界自我满足，这个方法就是做梦。每次闭上眼睛，就是一次新的冒险。假如你足够厉害，甚至可以连续几天上演连续的剧情。有一段时间我沉迷武侠小说，于是连续几个夜晚，大脑都在梦中编造了我自己想象的武侠世界，任我闯荡。</p><p>故事创作这件事，其实在很久以前我就做过。这样的事更加久远了，它大约发生在我的中二时期，差不多就在小六的时候吧。那时并没有太多的学业和升学压力，看了很多漫画故事，脑子里全是一些中二的事。苦于年纪太小，文字表述有限，跟同学开始画火柴人，以火柴人为载体，创作各种各样的冒险故事。</p><p>只记得我们在一些空白的作业本上涂涂画画，先把格子一格一格地划好，然后在格子里面画火柴人和各种东西。因为没有美术功底，画的也很简单。但故事内容可一点也不简单。我敢保证，那时候绞尽脑汁，把我们能想到的故事，少年期待的冒险和中二的设定，全都以火柴人为载体表达出来了。</p><p>等到把一本厚厚的作业本画得满满的，成为一本精彩的火柴人大冒险故事，全班同学互相传阅，无不惊奇，那时候好不风光，可以说是少年时最得意的杰作。</p><p>再后来，由于住在学校，一众同学几乎天天腻在一起，一起吃饭一起玩，还住同一个寝室。我创作之兴大起，其时恰好读完水浒传，于是提笔开始写《校园水浒传》，故事皆取材于校园日常生活。</p><p>写了几篇，就被同学们传阅，便获惊叹无数，都要求我继续写下去，只觉自己是个连载小说的作者。后来应该是某位同学在上课的时候拿着我的唯一草稿在看，被班主任发现了，班主任收上去细看之后，应该是觉得这种创作能力要多加鼓励弘扬，有利于提升同学们的兴趣，有利于他的语文教学，便在课上夸赞起来。</p><p>甚至，把我的作品印在了当时的一本校园刊物上，供全校学生阅读。那本刊物叫《海螺声声》来着，只记得一般是用来印发一些优秀作文的。据说这个刊物的名字还是我们班主任取得，寓意学生们的作文、作品就像是散落在沙滩上的贝壳，无比珍贵。另一种更合理的解释是同学们的作品就像有些放在耳边有音乐的奇特贝壳。反正我是记不清了。</p><p>作品被“出版”了，除了特别开心外，还有些尴尬，感觉就好像是那种本来只属于自己的世界，突然被曝光，被所有人窥探，失去了原本的神奇和秘密。</p><p>从那一期之后，我再写了几篇，便没有再写下去了，不知是何原因。或许是感受到了侵犯？或许是灵感枯竭？或许是小学快要毕业？反正就是没有下文了。后来我才知道，人们对这种行为戏称“太监”。之后在追连载的网路小说时，我也深深体会到“太监”之恶毒。</p><p>再往前一点，小四还是小五的时候，写的一篇作文被当做优秀作文，在课堂上朗读，又是一件尴尬无比的事。对于一些尴尬的事，我记得还蛮清楚的。那次的渊源是在书店买了两本书，一本《死魂灵》，一本《茶花女》。我实在不知道为什么会头脑发热去拿这两本书。《死魂灵》比较薄，但是因为是俄国文学，译本也不怎么样，看得我两眼发懵；《茶花女》就比较有趣了，虽然厚了点，但是这种爱情故事读来最是轻松有趣。花了几天连夜看完了《茶花女》，当时被感动得眼泪直掉，正好当时是期中考吧，写作文的时候，写了篇读后感，名字就叫《读&lt;茶花女&gt;有感》，把这凄美的爱情故事如何感动我写得有模有样的，也许是老师也被我的真情实感所打动，然后就一举拿下了优秀作文。</p><p>当时我甚至有想要改写《茶花女》结局的想法，因为这种sad ending实在让我难受。至于为什么只有想法，没有实际行动，我也记不清了，也许是因为能力有限吧。《茶花女》和《死魂灵》现在还藏在我那一堆书中，提醒着我这些陈年旧事。</p><p>我觉得创作真的是件很牛比的事。每个作者都是一个全能的上帝，随意操控着、摆布着一个个书中世界的人物生离死别，悲欢离合。但没有灵感，没有脑洞，没有文笔，还没有阅历和经历，真的是半点也无法写出来的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迷茫的时候，总会想要去干一些异想天开的事。比如最近多看了几本应当被划分进文学著作类型的书，就想着作家真的是好生厉害，要不我去跨考个中文系，悄咪咪地混进文学的大门算了。&lt;br&gt;
    
    </summary>
    
    
      <category term="胡思乱想" scheme="http://yoursite.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
</feed>
